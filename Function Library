#ADMINISTRATIVE TOOLS
from datetime import datetime
import os
import json
from typing import List, Dict


# SIMPLE FUNCTION
def approve_artwork(artwork_id: str) -> dict:
    """Mark an artwork as approved.

    Args:
        artwork_id (str): Unique ID of the artwork.

    Returns:
        dict: Approval record with artwork ID, status, and timestamp.

    Raises:
        ValueError: If artwork_id is missing or invalid.
    """
    if not isinstance(artwork_id, str) or not artwork_id.strip():
        raise ValueError("artwork_id must be a non-empty string.")
    approval_time = datetime.utcnow().isoformat()
    return {"artwork_id": artwork_id, "status": "approved", "approved_at": approval_time}


# SIMPLE FUNCTION 
def flag_artwork(artwork_id: str, reason: str) -> dict:
    """Flag an artwork for review due to inappropriate or incomplete content.

    Args:
        artwork_id (str): Unique ID of the artwork.
        reason (str): Description of why the item was flagged.

    Returns:
        dict: Record of the flag event containing ID, reason, and timestamp.

    Raises:
        ValueError: If artwork_id or reason are missing or invalid.
    """
    if not all(isinstance(v, str) and v.strip() for v in [artwork_id, reason]):
        raise ValueError("artwork_id and reason must be non-empty strings.")
    return {
        "artwork_id": artwork_id.strip(),
        "reason": reason.strip(),
        "status": "flagged",
        "timestamp": datetime.utcnow().isoformat()
    }


# MEDIUM FUNCTION
def audit_log(event: str, user_id: str, details: dict = None, log_file: str = "audit_log.json") -> dict:
    """Record a user or system event in a persistent audit log file.

    Args:
        event (str): Description of the event (e.g., 'Artwork Approved').
        user_id (str): ID of the user performing the action.
        details (dict, optional): Additional metadata for the event.
        log_file (str): File path for storing logs.

    Returns:
        dict: The created audit record including timestamp.

    Raises:
        ValueError: If event or user_id are missing.
        IOError: If the log file cannot be read or written.
    """
    if not all(isinstance(v, str) and v.strip() for v in [event, user_id]):
        raise ValueError("event and user_id must be non-empty strings.")

    log_entry = {
        "timestamp": datetime.utcnow().isoformat(),
        "user_id": user_id.strip(),
        "event": event.strip(),
        "details": details or {}
    }

    try:
        logs = []
        if os.path.exists(log_file):
            with open(log_file, "r", encoding="utf-8") as f:
                logs = json.load(f)
        logs.append(log_entry)
        with open(log_file, "w", encoding="utf-8") as f:
            json.dump(logs, f, indent=2)
    except Exception as e:
        raise IOError(f"Failed to write to audit log: {e}") from e

    return log_entry


#  MEDIUM FUNCTION
def backup_archive(source_dir: str, destination_dir: str) -> str:
    """Simulate a backup by verifying source contents and generating a timestamped report.

    Args:
        source_dir (str): Directory containing archive files.
        destination_dir (str): Directory to save backups.

    Returns:
        str: Path to the simulated backup report.

    Raises:
        FileNotFoundError: If the source directory does not exist.
        OSError: If report file cannot be created.
    """
    if not isinstance(source_dir, str) or not os.path.isdir(source_dir):
        raise FileNotFoundError(f"Source directory not found: {source_dir}")
    if not isinstance(destination_dir, str):
        raise ValueError("destination_dir must be a string.")

    timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
    report_path = os.path.join(destination_dir, f"backup_report_{timestamp}.txt")
    os.makedirs(destination_dir, exist_ok=True)

    try:
        files = os.listdir(source_dir)
        summary = [
            f"Backup created at {timestamp}",
            f"Source: {source_dir}",
            f"Destination: {destination_dir}",
            f"Total files: {len(files)}",
            "",
            "Files included:"
        ]
        for f in files:
            summary.append(f"- {f}")
        with open(report_path, "w", encoding="utf-8") as report:
            report.write("\n".join(summary))
    except Exception as e:
        raise OSError(f"Failed to generate backup report: {e}") from e

    return report_path


# COMPLEX FUNCTION 
def review_artwork_submissions(submissions: List[Dict]) -> List[Dict]:
    """Process and evaluate multiple artwork submissions, approving or flagging based on completeness.

    Args:
        submissions (List[Dict]): A list of submissions. Each should contain
            'title', 'description', 'artist_id', and 'medium'.

    Returns:
        List[Dict]: Submissions with review results and issue tracking.

    Raises:
        TypeError: If submissions is not a list of dictionaries.
        ValueError: If any submission is missing required fields.
    """
    if not isinstance(submissions, list):
        raise TypeError("submissions must be a list of dictionaries.")

    required_fields = {"title", "description", "artist_id", "medium"}
    reviewed = []

    for sub in submissions:
        if not isinstance(sub, dict):
            raise TypeError("Each submission must be a dictionary.")
        missing = [f for f in required_fields if not sub.get(f)]
        review = sub.copy()
        review["reviewed_at"] = datetime.utcnow().isoformat()
        if missing:
            review["status"] = "flagged"
            review["issues"] = [f"Missing field: {f}" for f in missing]
        else:
            review["status"] = "approved"
            review["issues"] = []
        reviewed.append(review)

    approved = sum(1 for s in reviewed if s["status"] == "approved")
    flagged = len(reviewed) - approved
    summary = {
        "total_submissions": len(reviewed),
        "approved": approved,
        "flagged": flagged,
        "timestamp": datetime.utcnow().isoformat()
    }

    print("Review Summary:", json.dumps(summary, indent=2))
    return reviewed





#ARTWORK MANAGEMENT
#FUNCTION 1
database = []  
def upload_artwork(user_id, artwork_data, metadata):
    """
    Upload new artwork along with metadata such as title, description, medium, and size.

    Args:
        user_id (str): The unique ID of the user uploading the artwork.
        artwork_data (str): The artwork file data or file path.
        metadata (dict): A dictionary containing artwork details like:
            - title (str)
            - description (str)
            - medium (str)
            - size (str)
            - date (str)

    Returns:
        str: A confirmation message including the artwork title.

    Raises:
        ValueError: If required fields (title or description) are missing.
    """
    if not metadata.get("title") or not metadata.get("description"):
        raise ValueError("Both 'title' and 'description' are required.")

    artwork = {
        "user_id": user_id,
        "image": artwork_data,
        "title": metadata.get("title"),
        "description": metadata.get("description"),
        "medium": metadata.get("medium"),
        "size": metadata.get("size"),
        "date": metadata.get("date")
    }
    database.append(artwork)
    return f"Artwork '{artwork['title']}' uploaded successfully!"


#FUNCTION 2
def edit_artwork(artwork_id, updated_data):
    """
    Modify details about an existing artwork.

    Args:
        artwork_id (int): The ID of the artwork to edit.
        updated_data (dict): Key-value pairs of fields to update (e.g., title, description).

    Returns:
        str: Confirmation message after updating the artwork.

    Raises:
        IndexError: If the artwork_id does not exist.
    """
    if artwork_id >= len(database) or artwork_id < 0:
        raise IndexError("Artwork not found.")
    database[artwork_id].update(updated_data)
    return f"Artwork '{database[artwork_id].get('title', 'Untitled')}' updated successfully!"


#FUNCTION 3
def delete_artwork(user_id, artwork_id, is_admin=False):
    """
    Remove an artwork from the database (admin or creator only).

    Args:
        user_id (str): The ID of the user attempting to delete the artwork.
        artwork_id (int): The index or unique ID of the artwork to delete.
        is_admin (bool, optional): Whether the user has admin privileges. Defaults to False.

    Returns:
        str: A message confirming successful deletion.

    Raises:
        IndexError: If the artwork_id does not exist.
        PermissionError: If the user is not authorized to delete the artwork.
    """
    if artwork_id >= len(database) or artwork_id < 0:
        raise IndexError("Artwork not found.")
    artwork = database[artwork_id]
    owner_id = artwork.get("user_id")
    if user_id != owner_id and not is_admin:
        raise PermissionError("You do not have permission to delete this artwork.")
    print(f"User '{user_id}' is deleting artwork '{artwork.get('title', 'Untitled')}'.")
    deleted = database.pop(artwork_id)
    return f"Artwork '{deleted.get('title', 'Untitled')}' deleted successfully."


#FUNCTION 4
def list_artworks(filter_criteria=None):
    """
    Display a list of artworks based on various filter criteria.

    Args:
        filter_criteria (dict, optional): A dictionary of fields and values to filter by.
            Example:
                {
                    "user_id": "u1",
                    "medium": "Oil on Canvas",
                    "year": "2024",
                    "department": "Fine Arts"
                }
            If None or empty, all artworks will be listed.

    Returns:
        list: A list of artworks (dicts) matching the provided filters.

    Raises:
        ValueError: If filter_criteria is not a dictionary.
    """

    if "database" not in globals() or not isinstance(database, list):
        print("No artwork database found.")
        return []
    if filter_criteria is None:
        filter_criteria = {}
    elif not isinstance(filter_criteria, dict):
        raise ValueError("Filter criteria must be a dictionary.")
    print("\nðŸ“‹ Listing Artworks")
    print("-" * 50)
    results = []
    for art in database:
        match = True
        for key, value in filter_criteria.items():
            if str(art.get(key, "")).lower() != str(value).lower():
                match = False
                break
        if match:
            results.append(art)

    if not results:
        print("No artworks match the given filters.")
    else:
        for i, art in enumerate(results, start=1):
            title = art.get("title", "Untitled")
            user = art.get("user_id", "Unknown")
            medium = art.get("medium", "Unknown Medium")
            date = art.get("date", "Unknown Date")
            print(f"{i}. {title} by {user} | {medium} | {date}")
    print(f"\nTotal found: {len(results)}")
    return results




#ORGANIZAION & TAGGING
