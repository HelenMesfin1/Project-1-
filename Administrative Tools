from datetime import datetime
import os
import json
from typing import List, Dict


# SIMPLE FUNCTION
def approve_artwork(artwork_id: str) -> dict:
    """Mark an artwork as approved.

    Args:
        artwork_id (str): Unique ID of the artwork.

    Returns:
        dict: Approval record with artwork ID, status, and timestamp.

    Raises:
        ValueError: If artwork_id is missing or invalid.
    """
    if not isinstance(artwork_id, str) or not artwork_id.strip():
        raise ValueError("artwork_id must be a non-empty string.")
    approval_time = datetime.utcnow().isoformat()
    return {"artwork_id": artwork_id, "status": "approved", "approved_at": approval_time}


# SIMPLE FUNCTION 
def flag_artwork(artwork_id: str, reason: str) -> dict:
    """Flag an artwork for review due to inappropriate or incomplete content.

    Args:
        artwork_id (str): Unique ID of the artwork.
        reason (str): Description of why the item was flagged.

    Returns:
        dict: Record of the flag event containing ID, reason, and timestamp.

    Raises:
        ValueError: If artwork_id or reason are missing or invalid.
    """
    if not all(isinstance(v, str) and v.strip() for v in [artwork_id, reason]):
        raise ValueError("artwork_id and reason must be non-empty strings.")
    return {
        "artwork_id": artwork_id.strip(),
        "reason": reason.strip(),
        "status": "flagged",
        "timestamp": datetime.utcnow().isoformat()
    }


# MEDIUM FUNCTION
def audit_log(event: str, user_id: str, details: dict = None, log_file: str = "audit_log.json") -> dict:
    """Record a user or system event in a persistent audit log file.

    Args:
        event (str): Description of the event (e.g., 'Artwork Approved').
        user_id (str): ID of the user performing the action.
        details (dict, optional): Additional metadata for the event.
        log_file (str): File path for storing logs.

    Returns:
        dict: The created audit record including timestamp.

    Raises:
        ValueError: If event or user_id are missing.
        IOError: If the log file cannot be read or written.
    """
    if not all(isinstance(v, str) and v.strip() for v in [event, user_id]):
        raise ValueError("event and user_id must be non-empty strings.")

    log_entry = {
        "timestamp": datetime.utcnow().isoformat(),
        "user_id": user_id.strip(),
        "event": event.strip(),
        "details": details or {}
    }

    try:
        logs = []
        if os.path.exists(log_file):
            with open(log_file, "r", encoding="utf-8") as f:
                logs = json.load(f)
        logs.append(log_entry)
        with open(log_file, "w", encoding="utf-8") as f:
            json.dump(logs, f, indent=2)
    except Exception as e:
        raise IOError(f"Failed to write to audit log: {e}") from e

    return log_entry


#  MEDIUM FUNCTION
def backup_archive(source_dir: str, destination_dir: str) -> str:
    """Simulate a backup by verifying source contents and generating a timestamped report.

    Args:
        source_dir (str): Directory containing archive files.
        destination_dir (str): Directory to save backups.

    Returns:
        str: Path to the simulated backup report.

    Raises:
        FileNotFoundError: If the source directory does not exist.
        OSError: If report file cannot be created.
    """
    if not isinstance(source_dir, str) or not os.path.isdir(source_dir):
        raise FileNotFoundError(f"Source directory not found: {source_dir}")
    if not isinstance(destination_dir, str):
        raise ValueError("destination_dir must be a string.")

    timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
    report_path = os.path.join(destination_dir, f"backup_report_{timestamp}.txt")
    os.makedirs(destination_dir, exist_ok=True)

    try:
        files = os.listdir(source_dir)
        summary = [
            f"Backup created at {timestamp}",
            f"Source: {source_dir}",
            f"Destination: {destination_dir}",
            f"Total files: {len(files)}",
            "",
            "Files included:"
        ]
        for f in files:
            summary.append(f"- {f}")
        with open(report_path, "w", encoding="utf-8") as report:
            report.write("\n".join(summary))
    except Exception as e:
        raise OSError(f"Failed to generate backup report: {e}") from e

    return report_path


# COMPLEX FUNCTION 
def review_artwork_submissions(submissions: List[Dict]) -> List[Dict]:
    """Process and evaluate multiple artwork submissions, approving or flagging based on completeness.

    Args:
        submissions (List[Dict]): A list of submissions. Each should contain
            'title', 'description', 'artist_id', and 'medium'.

    Returns:
        List[Dict]: Submissions with review results and issue tracking.

    Raises:
        TypeError: If submissions is not a list of dictionaries.
        ValueError: If any submission is missing required fields.
    """
    if not isinstance(submissions, list):
        raise TypeError("submissions must be a list of dictionaries.")

    required_fields = {"title", "description", "artist_id", "medium"}
    reviewed = []

    for sub in submissions:
        if not isinstance(sub, dict):
            raise TypeError("Each submission must be a dictionary.")
        missing = [f for f in required_fields if not sub.get(f)]
        review = sub.copy()
        review["reviewed_at"] = datetime.utcnow().isoformat()
        if missing:
            review["status"] = "flagged"
            review["issues"] = [f"Missing field: {f}" for f in missing]
        else:
            review["status"] = "approved"
            review["issues"] = []
        reviewed.append(review)

    approved = sum(1 for s in reviewed if s["status"] == "approved")
    flagged = len(reviewed) - approved
    summary = {
        "total_submissions": len(reviewed),
        "approved": approved,
        "flagged": flagged,
        "timestamp": datetime.utcnow().isoformat()
    }

    print("Review Summary:", json.dumps(summary, indent=2))
    return reviewed




from itertools import groupby
from datetime import datetime
import os
import json
from typing import List, Dict

class ArtCollection:
    """Collection of artworks with tagging, search, sort, grouping, and admin tools."""

    def __init__(self, artworks=None):
        self._artworks = artworks if artworks else []
        self._admin_log = []

    @property
    def artworks(self):
        return list(self._artworks)

    @property
    def admin_log(self):
        return list(self._admin_log)

    def _get_artwork_by_id(self, artwork_id):
        for art in self._artworks:
            if art["id"] == artwork_id:
                return art
        return None

    def _log_action(self, event, user_id="Admin", details=None):
        log_entry = {
            "timestamp": datetime.utcnow().isoformat(),
            "user_id": user_id,
            "event": event,
            "details": details or {}
        }
        self._admin_log.append(log_entry)
        return log_entry

    def add_artwork(self, new_artwork, user_id="Admin"):
        required_keys = {"id", "title", "artist", "year", "medium", "department", "tags"}
        if not isinstance(new_artwork, dict) or not required_keys.issubset(new_artwork.keys()):
            return
        if self._get_artwork_by_id(new_artwork["id"]):
            return
        self._artworks.append(new_artwork)
        self._log_action(f"Added artwork '{new_artwork['title']}'", user_id)

    def add_tag(self, artwork_id, tag, user_id="Admin"):
        art = self._get_artwork_by_id(artwork_id)
        if art:
            if tag not in art["tags"]:
                art["tags"].append(tag)
                self._log_action(f"Added tag '{tag}' to '{art['title']}'", user_id)

    def search_artworks(self, query="", filters=None):
        if filters is None:
            filters = {}
        results = []
        for art in self._artworks:
            if query.lower() in art["title"].lower() or query.lower() in art["artist"].lower():
                match = all(str(art.get(k)).lower() == str(v).lower() for k, v in filters.items())
                if match:
                    results.append(art)
        return results

    def sort_artworks(self, order_by="year"):
        try:
            return sorted(self._artworks, key=lambda x: x[order_by])
        except KeyError:
            return self._artworks

    def group_by(self, attribute):
        try:
            sorted_arts = sorted(self._artworks, key=lambda x: x[attribute])
            return {k: list(g) for k, g in groupby(sorted_arts, key=lambda x: x[attribute])}
        except KeyError:
            return {}

    def display_all(self):
        return [f"{art['title']} ({art['year']}) by {art['artist']}" for art in self._artworks]

    def approve_artwork(self, artwork_id, user_id="Admin"):
        art = self._get_artwork_by_id(artwork_id)
        if art:
            art["status"] = "approved"
            art["approved_at"] = datetime.utcnow().isoformat()
            self._log_action(f"Artwork '{art['title']}' approved", user_id)
            return art

    def flag_artwork(self, artwork_id, reason, user_id="Admin"):
        art = self._get_artwork_by_id(artwork_id)
        if art:
            art["status"] = "flagged"
            art["flag_reason"] = reason
            art["flagged_at"] = datetime.utcnow().isoformat()
            self._log

